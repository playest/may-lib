import fr.irit.smac.may.lib.components.messaging.interfaces.ReliableSend
import fr.irit.smac.may.lib.interfaces.Broadcast
import fr.irit.smac.may.lib.interfaces.Do
import fr.irit.smac.may.lib.interfaces.MapGet
import fr.irit.smac.may.lib.interfaces.Pull
import fr.irit.smac.may.lib.interfaces.Push
import fr.irit.smac.may.lib.interfaces.Send

namespace fr.irit.smac.may.lib.components.messaging {


	ecosystem Broadcaster[T, Ref] {
		species Agent {
			provides bc: Broadcast[T]
		}
		requires deposit: Send[T, Ref]
		provides broadcast: Push[T]
		provides add: Push[Ref]
		provides remove: Push[Ref]
	}

	namespace receiver {
		ecosystem Receiver[MsgType] {
			species Agent(name:String) {
				requires put: Push[MsgType]
				provides me: Pull[AgentRef]
				provides stop: Do
				provides send: ReliableSend[MsgType, AgentRef]
			}
			provides deposit: ReliableSend[MsgType, AgentRef]
		}
	}
	
	namespace callable {
		
		// est-ce que ce n'est juste une version spéciale du collection map sans map ? si!
		ecosystem Callable[I] {
			species Callee {
				requires toCall: I
				provides me: Pull[CallRef]
				provides stop: Do
			}
			species Caller {
				provides call: MapGet[CallRef,I]
			}
			provides call: MapGet[CallRef,I]
		}
	}
	
	// to combine for example with meta.Data and an infrastructure component generating the references...
	ecosystem MapReceiver[Msg,RealRef,Ref] {
		species Agent {
			// value
			requires value: Pull[RealRef]
			// key
			requires key: Pull[Ref]
			provides disconnect: Do
		}
		// send for the key
		provides depositKey: Send[Msg,Ref]
		
		// send for the value
		requires depositValue: Send[Msg,RealRef]
	}
	
	namespace distributed {
		
		
		// a bit useless now it seems…
		component DistributedMessaging[Msg,NodeRef] {
			provides generateRef: Pull[DistRef[NodeRef]]

			requires myNode: Pull[NodeRef]
			
			// local
			provides send: Send[Msg,DistRef[NodeRef]]
			requires deposit: Send[Msg,DistRef[NodeRef]]
			
			// toward exterior
			requires distOut: Send[DistributedMessage[Msg,NodeRef],NodeRef]
			provides distIn: Push[DistributedMessage[Msg,NodeRef]]
		}
		
		component DistributedCommunication[T] {
			
			provides nodeName: Pull[String]
			
			// local
			provides in: Send[T,String]
			requires out: Push[T]
			
			// toward exterior
			requires broadcast: Push[DistributedInfo[T]]
			provides handle: Push[DistributedInfo[T]]
		}
	}
	
}