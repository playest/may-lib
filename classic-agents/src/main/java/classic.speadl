import fr.irit.smac.may.lib.classic.impl.AbstractClassicBehaviour
import fr.irit.smac.may.lib.classic.interfaces.CreateClassic
import fr.irit.smac.may.lib.classic.interfaces.CreateNamed
import fr.irit.smac.may.lib.classic.interfaces.CreateRemoteClassic
import fr.irit.smac.may.lib.classic.namedpub.AbstractObservedBehaviour
import fr.irit.smac.may.lib.classic.namedpub.AbstractObserverBehaviour
import fr.irit.smac.may.lib.classic.namedpub.NamedPublishMASFactory
import fr.irit.smac.may.lib.classic.remote.impl.AbstractRemoteClassicBehaviour
import fr.irit.smac.may.lib.components.controlflow.SequentialDispatcher
import fr.irit.smac.may.lib.components.interactions.AsyncReceiver
import fr.irit.smac.may.lib.components.interactions.DirectReferences
import fr.irit.smac.may.lib.components.interactions.MapReferences
import fr.irit.smac.may.lib.components.interactions.ValuePublisher
import fr.irit.smac.may.lib.components.interactions.directreferences.DirRef
import fr.irit.smac.may.lib.components.interactions.interfaces.Observe
import fr.irit.smac.may.lib.components.messaging.receiver.AgentRef
import fr.irit.smac.may.lib.components.messaging.receiver.Receiver
import fr.irit.smac.may.lib.components.meta.Forward
import fr.irit.smac.may.lib.components.remote.messaging.receiver.RemoteAgentRef
import fr.irit.smac.may.lib.components.remote.messaging.receiver.RemoteReceiver
import fr.irit.smac.may.lib.components.remote.place.Place
import fr.irit.smac.may.lib.components.remote.place.Placed
import fr.irit.smac.may.lib.components.scheduling.Clock
import fr.irit.smac.may.lib.components.scheduling.ExecutorService
import fr.irit.smac.may.lib.components.scheduling.Scheduled
import fr.irit.smac.may.lib.components.scheduling.Scheduler
import fr.irit.smac.may.lib.components.scheduling.SchedulingControllerGUI
import fr.irit.smac.may.lib.interfaces.Do
import fr.irit.smac.may.lib.interfaces.Pull
import fr.irit.smac.may.lib.interfaces.Push
import fr.irit.smac.may.lib.interfaces.Send
import java.util.concurrent.Executor

namespace fr.irit.smac.may.lib.classic {

	namespace namedPublish {
		
		
		component ObservedBehaviour {
			provides cycle: Do
			requires changeValue: Push[Integer]
		}
		
		component ObserverBehaviour[Ref] {
			provides cycle: Do
			requires observe: Observe[Integer,Ref]
		}
		
		ecosystem NamedPublishMAS {
			
			provides create: NamedPublishMASFactory
			
			part refs: MapReferences[Pull[Integer],String]
			part observeds: ValuePublisher[Integer,String] {
				bind call to refs.call
			}
			
			part executor: ExecutorService
			part schedule: Scheduled {
				bind sched to executor.exec
			}
			part clock: Clock {
				bind sched to executor.exec
				bind tick to schedule.tick
			}
			part gui: SchedulingControllerGUI {
				bind control to clock.control
			}

			species Observed(name: String, beha: AbstractObservedBehaviour) {

				use sched: schedule.Agent {
					bind cycle to beh.cycle
				}
				
				part beh: ObservedBehaviour {
					bind changeValue to observed.set 
				}
			
				use ref: refs.Callee(name) {
					bind toCall to observed.toCall
				}
				use observed: observeds.PublisherPush
				
			}
			
			species Observer(beha: AbstractObserverBehaviour[String]) {
				
				use sched: schedule.Agent {
					bind cycle to beh.cycle
				}
				
				part beh: ObserverBehaviour[String] {
					bind observe to observer.observe
				}
				use observer: observeds.Observer
				
			}
			
		}
	}

	namespace named {
		
		
		ecosystem ClassicNamed[Msg] {
			
			provides send: Send[Msg, String] = receive.deposit
			provides create: CreateNamed[Msg, String]
			
			part scheduler: Scheduler {
				bind executor to executor.exec
			}
			
			part fact: Forward[CreateNamed[Msg, String]] {
				bind i to create
			}
			
			part refs: MapReferences[Push[Msg],String]
			part receive: AsyncReceiver[Msg,String] {
				bind call to refs.call
			}
			
			part executor: ExecutorService
			
			species ClassicNamedAgent(beh: AbstractClassicNamedBehaviour[Msg,String], name: String) {
			//species ClassicNamedAgent(name: String) {
				part arch: ClassicNamedAgentComponent[Msg, String] {
					bind send to ss.send
					bind executor to s.exec
					bind die to s.stop
					bind create to f.a
					bind me to ref.me
				}

				use s: scheduler.Agent

				use f: fact.Agent

				use receive: receive.Receiver {
					bind put to arch.put
				}
				use ref: refs.Callee(name) {
					bind toCall to receive.toCall
				}

				use ss: receive.Sender
			}
		}
		
		component ClassicNamedBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateNamed[Msg, Ref]
		}
		
		component ClassicNamedAgentComponent[Msg, Ref] {
			
			provides put: Push[Msg] = dispatcher.dispatch
			
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires executor: Executor
			requires die: Do
			requires create: CreateNamed[Msg, Ref]

			part dispatcher: SequentialDispatcher[Msg] {
				bind executor to executor
				bind handler to beh.cycle
			}
			
			part beh: ClassicNamedBehaviour[Msg, Ref] {
				bind send to send
				bind me to me
				bind die to die
				bind create to create
			}

		}
	}

	namespace local {
		
		component ClassicBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateClassic[Msg, Ref]
		}
		
		ecosystem Classic[Msg] {

			provides send: Send[Msg, DirRef] = receive.deposit
			provides create: CreateClassic[Msg, DirRef]
			provides stop: Do = executor.stop

			part scheduler: Scheduler {
				bind executor to executor.exec
			}
			
			part refs: DirectReferences[Push[Msg]]
			part receive: AsyncReceiver[Msg,DirRef] {
				bind call to refs.call
			}

			part fact: Forward[CreateClassic[Msg, DirRef]] {
				bind i to create
			}

			part executor: ExecutorService

			species ClassicAgent(beh: AbstractClassicBehaviour[Msg,DirRef], name: String) {
			//species ClassicAgent(name: String) {
				provides me: Pull[DirRef] = ref.me
				
				part arch: ClassicAgentComponent[Msg, DirRef] {
					bind send to ss.send
					bind me to ref.me
					bind executor to s.exec
					bind die to s.stop
					bind create to f.a
				}

				use s: scheduler.Agent

				use f: fact.Agent
				
				use receive: receive.Receiver {
					bind put to arch.put
				}
				use ref: refs.Callee(name) {
					bind toCall to receive.toCall
				}

				use ss: receive.Sender
			}
		}

		component ClassicAgentComponent[Msg, Ref] {
			provides put: Push[Msg] = dispatcher.dispatch
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires executor: Executor
			requires die: Do
			requires create: CreateClassic[Msg, Ref]

			part dispatcher: SequentialDispatcher[Msg] {
				bind executor to executor
				bind handler to beh.cycle
			}
			part beh: ClassicBehaviour[Msg, Ref] {
				bind send to send
				bind me to me
				bind die to die
				bind create to create
			}
		}
	}

	namespace remote {

		component RemoteClassicBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateRemoteClassic[Msg, Ref]
		}

		component RemoteClassicAgentComponent[Msg, Ref] {
			provides put: Push[Msg] = dispatcher.dispatch
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires executor: Executor
			provides die: Do
			requires stopExec: Do
			requires stopReceive: Do
			requires create: CreateRemoteClassic[Msg, Ref]

			part dispatcher: SequentialDispatcher[Msg] {
				bind executor to executor
				bind handler to beh.cycle
			}
			part beh: RemoteClassicBehaviour[Msg, Ref] {
				bind send to send
				bind me to me
				bind die to die
				bind create to create
			}
		}

		ecosystem RemoteFactory[Msg, Ref] {
			species Agent {
				provides create: CreateRemoteClassic[Msg, Ref]
			}
			requires infraCreate: CreateRemoteClassic[Msg, Ref]
			provides factCreate: CreateRemoteClassic[Msg, Ref]
			requires thisPlace: Pull[Place]
		}
		


		ecosystem RemoteClassic[Msg] {

			provides send: Send[Msg, RemoteAgentRef] = remReceive.deposit
			provides thisPlace: Pull[Place] = placed.thisPlace
			provides create: CreateRemoteClassic[Msg, RemoteAgentRef]

			part scheduler: Scheduler {
				bind executor to executor.exec
			}

			part sender: Forward[Send[Msg, RemoteAgentRef]] {
				bind i to remReceive.deposit
			}

			part receive: Receiver[Msg]

			part placed: Placed

			part remReceive: RemoteReceiver[Msg, AgentRef] {
				bind localDeposit to receive.deposit
				bind myPlace to placed.thisPlace
			}

			part fact: RemoteFactory[Msg, RemoteAgentRef] {
				bind infraCreate to create
				bind thisPlace to placed.thisPlace
			}

			part executor: ExecutorService

			species ClassicAgent(beh: AbstractRemoteClassicBehaviour[Msg, RemoteAgentRef], name: String) {
			//species ClassicAgent(name: String) {
				provides ref: Pull[RemoteAgentRef] = rr.me
				part arch: RemoteClassicAgentComponent[Msg, RemoteAgentRef] {
					bind send to ss.a
					bind me to rr.me
					bind stopExec to s.stop
					bind stopReceive to rr.disconnect
					bind executor to s.exec
					bind create to f.create
				}
				use p: placed.Agent
				use f: fact.Agent
				use s: scheduler.Agent
				use r: receive.Agent(name) {
					bind put to arch.put
				}
				use ss: sender.Agent
				use rr: remReceive.Agent {
					bind localMe to r.me
				}
			}
		}
	}
}