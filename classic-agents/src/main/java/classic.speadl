
import java.lang.String
import fr.irit.smac.may.lib.interfaces.*
import fr.irit.smac.may.lib.classic.interfaces.*
import fr.irit.smac.may.lib.components.meta.*
import fr.irit.smac.may.lib.components.scheduling.*
import fr.irit.smac.may.lib.components.messaging.*
import fr.irit.smac.may.lib.components.messaging.receiver.*
import fr.irit.smac.may.lib.components.controlflow.*
import fr.irit.smac.may.lib.components.remote.place.*
import fr.irit.smac.may.lib.components.remote.messaging.receiver.*
import fr.irit.smac.may.lib.components.remote.messaging.receiver.RemoteAgentRef
import fr.irit.smac.may.lib.components.remote.place.Place
import fr.irit.smac.may.lib.components.messaging.receiver.AgentRef

import java.util.concurrent.Executor

import fr.irit.smac.may.lib.classic.*

namespace fr.irit.smac.may.lib.classic {

	namespace named {
		
		ecosystem ClassicNamed[Msg] {
			provides send: Send[Msg, String] = receive.depositKey
			provides create: CreateNamed[Msg, String]
			
			part scheduler: Scheduler {
				bind infraSched to executor.exec
			}

			part sender: Forward[Send[Msg, String]] {
				bind i to receive.depositKey
			}
			
			part fact: Forward[CreateNamed[Msg, String]] {
				bind i toThis create
			}
			
			part realReceive: Receiver[Msg]
			
			part receive: MapReceiver[Msg,AgentRef,String] {
				bind depositValue to realReceive.deposit
			}
			
			part executor: ExecutorService
			
			species ClassicNamedAgent(beh: named.ClassicNamedBehaviour[Msg,String], name: String) {
			//species ClassicNamedAgent(name: String) {
				part arch: ClassicNamedAgentComponent[Msg, String] {
					bind send to ss.a
					bind executor to s.sched
					bind die to s.stop
					bind create to f.a
				}

				use s: scheduler.Agent

				use f: fact.Agent

				use r: receive.Agent {
					bind key to arch.me
					bind value to rr.me
				}
				
				use rr: realReceive.Agent(name) {
					bind put to arch.put
				}

				use ss: sender.Agent
			}
		}
		
		component ClassicNamedBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateNamed[Msg, Ref]
		}
		
		component ClassicNamedAgentComponent[Msg, Ref] {
			
			provides put: Push[Msg] = dispatcher.dispatch
			provides me: Pull[Ref] = name.data
			
			requires send: Send[Msg, Ref]
			requires executor: Executor
			requires die: Do
			requires create: CreateNamed[Msg, Ref]

			part name: Data[Ref]

			part dispatcher: SequentialDispatcher[Msg] {
				bind executor toThis executor
				bind handler to beh.cycle
			}
			
			part beh: ClassicNamedBehaviour[Msg, Ref] {
				bind send toThis send
				bind me toThis me
				bind die toThis die
				bind create toThis create
			}

		}
	}

	namespace local {
		
		component ClassicBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateClassic[Msg, Ref]
		}
		
		ecosystem Classic[Msg] {

			provides send: Send[Msg, AgentRef] = receive.deposit
			provides create: CreateClassic[Msg, AgentRef]
			provides stop: Do = executor.stop

			part scheduler: Scheduler {
				bind infraSched to executor.exec
			}

			part sender: Forward[Send[Msg, AgentRef]] {
				bind i to receive.deposit
			}

			part receive: Receiver[Msg]

			part fact: fr.irit.smac.may.lib.components.meta.Forward[CreateClassic[Msg, AgentRef]] {
				bind i toThis create
			}

			part executor: ExecutorService

			species ClassicAgent(beh: local.ClassicBehaviour[Msg,AgentRef], name: String) {
			//species ClassicAgent(name: String) {
				provides ref: Pull[AgentRef] = r.me
				
				part arch: ClassicAgentComponent[Msg, AgentRef] {
					bind send to ss.a
					bind me to r.me
					bind executor to s.sched
					bind die to s.stop
					bind create to f.a
				}

				use s: scheduler.Agent

				use f: fact.Agent

				use r: receive.Agent(name) { 
					bind put to arch.put
				}

				use ss: sender.Agent
			}
		}

		component ClassicAgentComponent[Msg, Ref] {
			provides put: Push[Msg] = dispatcher.dispatch
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires executor: Executor
			requires die: Do
			requires create: CreateClassic[Msg, Ref]

			part dispatcher: SequentialDispatcher[Msg] {
				bind executor toThis executor
				bind handler to beh.cycle
			}
			part beh: ClassicBehaviour[Msg, Ref] {
				bind send toThis send
				bind me toThis me
				bind die toThis die
				bind create toThis create
			}
		}
	}

	namespace remote {

		component RemoteClassicBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateRemoteClassic[Msg, Ref]
		}

		component RemoteClassicAgentComponent[Msg, Ref] {
			provides put: Push[Msg] = dispatcher.dispatch
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires executor: Executor
			provides die: Do
			requires stopExec: Do
			requires stopReceive: Do
			requires create: CreateRemoteClassic[Msg, Ref]

			part dispatcher: SequentialDispatcher[Msg] {
				bind executor toThis executor
				bind handler to beh.cycle
			}
			part beh: RemoteClassicBehaviour[Msg, Ref] {
				bind send toThis send
				bind me toThis me
				bind die toThis die
				bind create toThis create
			}
		}

		ecosystem RemoteFactory[Msg, Ref] {
			species Agent {
				provides create: CreateRemoteClassic[Msg, Ref]
			}
			requires infraCreate: CreateRemoteClassic[Msg, Ref]
			provides factCreate: CreateRemoteClassic[Msg, Ref]
			requires thisPlace: Pull[Place]
		}
		


		ecosystem RemoteClassic[Msg] {

			provides send: Send[Msg, RemoteAgentRef] = remReceive.deposit
			provides thisPlace: Pull[Place] = placed.thisPlace
			provides create: CreateRemoteClassic[Msg, RemoteAgentRef]

			part scheduler: Scheduler {
				bind infraSched to executor.exec
			}

			part sender: Forward[Send[Msg, RemoteAgentRef]] {
				bind i to remReceive.deposit
			}

			part receive: Receiver[Msg]

			part placed: Placed

			part remReceive: RemoteReceiver[Msg, AgentRef] {
				bind localDeposit to receive.deposit
				bind myPlace to placed.thisPlace
			}

			part fact: RemoteFactory[Msg, RemoteAgentRef] {
				bind infraCreate toThis create
				bind thisPlace to placed.thisPlace
			}

			part executor: ExecutorService

			species ClassicAgent(beh: remote.RemoteClassicBehaviour[Msg, RemoteAgentRef], name: String) {
			//species ClassicAgent(name: String) {
				provides ref: Pull[RemoteAgentRef] = rr.me
				part arch: RemoteClassicAgentComponent[Msg, RemoteAgentRef] {
					bind send to ss.a
					bind me to rr.me
					bind stopExec to s.stop
					bind stopReceive to rr.disconnect
					bind executor to s.sched
					bind create to f.create
				}
				use p: placed.Agent
				use f: fact.Agent
				use s: scheduler.Agent
				use r: receive.Agent(name) {
					bind put to arch.put
				}
				use ss: sender.Agent
				use rr: remReceive.Agent {
					bind localMe to r.me
				}
			}
		}
	}
}